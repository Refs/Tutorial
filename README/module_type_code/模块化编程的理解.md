# 模块化编程的理解

> '设函数f(x)' 这句话是核心，中的核心；因为最贴近实战；

## 从处理服务器上面传来的data 的角度，来理解模块编程；

* 模块实质上就是一个函数，并不是从形式上，单写到某一个页面中，然后用define定义成一个块，才叫模块；其就是用来实现某个具体的功能；之所以采用特殊的写法AMD，仅仅是为了复用，与减少全局污染罢了；核心与函数一样，就是用来处理的（水木艾迪的思想，将向处理的东西传到函数里面，函数将你想要的东西，返回出来）

* 要有'设函数的思想'----这个思想太重要了，自己以前想通过，只是自己忘了，或没有贯通；  x 就代表现在自己已经拥有的， f(x)就代表是自己想得到的；核心的逻辑在于，我们可以先不将f(x)具体的内容写出来， 而是先将f(x)'设'出来；将f(x)'设'出来就可以接着向下面走了；

> 即对于这条主线来说，我们有x，但必须求得f(x) ，才能接着往下面走;而我们不愿意停止当前这条master 而跳到另外一天branch上面去写f函数的具体实现，我们采取的做法是将f(x)设出来，将其当作'设'的函数f 处理后的结果，接着向下走；回头再来考虑单个f 的具体实现； 

> '设函数f()'应该就是模块编程的核心思想了；这样我们的思维就可以一直处在一个层面上，一条线上，或一条master上面了，不用来回的去跳跃了；利用这个思想编程还是很舒服的；


* 这一点很类似于自己以前在研究高数的时候一样： 一个题目，有已知的条件x,y，有要求的结果z； 但不存在一个公式可以让我们可以通过x,y，求得z;  但有公式可以通过未知的量u a来求得z ;而通过xy 我们可以求得 u a ; 整个的逻辑就如下：

```js
//逻辑图如下：
z = f(u,a);
u = u(x,y);
a = a(x,y);

//我们正常的解决思路是，实现函数u 与 函数 a的逻辑，来求得 u 与 a的值；而后再实现函数f的逻辑， 来求得z 值；
// 但这种方式的有两种局限: 刚开始做题的我们并不知道要求u 与 a ; u 与 a 题目中根本就没有提到；我们只知道要去求z值,因为这是题目所要求的，我们是在求z的过程中，才知道中间需要去求u值与求a值； 也就是从刚一开始 我们的思维就处在求z的层位上； 
//此时有两个选择，一是思想脱离求z的层面，转入底层而去求u值与a值；去实现函数u与函数a的逻辑； 一种是思想不脱离顶层，直接将底层函数u与a设出来，u与a的值，就是u(x,y)与a(x,y) ，利用设的函数值u(x,y)与a(x,y)接着向下走；去完善函数f的逻辑；  走通之后，再来具体的实现函数u 与 函数a的逻辑； 

// 具体选择二的写法是： 代码分层写， 先实顶层f(u,a)/f(u(x,y),a(x,y)); 再去分块实现底层； 若底层a(x,y)实现的过程中需要求其它量，可以接着向下分层； 这样代码，就可以一层一层的写了；这种感觉还是很舒服的；


z = f(u(x,y),a(x,y))

```

> 设函数，所要达到的目标就是函数可以分层去写；